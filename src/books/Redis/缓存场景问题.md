---
title: 缓存场景问题
cover: https://upyun.yzyx.fun/8.jpg
date: 2024-07-26
category:
  - Redis
tag:
  - 学习资料
---

<!-- more -->
## 缓存穿透

- **定义**：缓存穿透是指查询一个不存在的数据，由于缓存和数据库中都没有，导致每次请求都直接查询数据库，这可能对数据库造成很大压力。
- **原因**：通常是因为攻击者故意发起大量不存在的数据查询请求，或者由于数据未被预先加载到缓存中。
- **解决方法**：使用空队列，也可以通过布隆过滤器（布谷鸟过滤器）拦截这些不存在的数据查询，或者使用缓存预热策略预先加载可能被查询的数据到缓存中。

## 缓存击穿

- **定义**：缓存击穿是指一个存在的key，在缓存中过期了，同时有大量的请求请求这个key，这些请求都会直接打到数据库上，导致数据库压力过大。
- **原因**：通常是因为某个热点数据在缓存中过期，而此时有大量的并发请求需要访问这个数据。
- **解决方法**：最好用的是单飞；也可以使用互斥锁或分布式锁来保证在缓存过期的情况下，只有一个请求能够访问数据库并回写缓存，其他请求则等待缓存重建完成。此外，可以设置缓存的过期时间更加分散，避免大量缓存同时过期。

## 缓存雪崩

- **定义**：缓存雪崩是指在某一个时刻出现大规模的缓存失效的情况，大量的请求直接打在数据库上面，可能会导致数据库宕机，如果这时重启数据库并不能解决根本问题，会再次造成缓存雪崩。
- **原因**：通常是因为缓存的过期时间设置不当，导致大量缓存在同一时间过期，或Redis宕机了。
- **解决方法**：
  - 为避免Redis宕机造成缓存雪崩，可以搭建Redis集群；
  - 尽量不要设置相同的过期时间，例如可以在原有的过期时间加上随机数；
  - 服务降级，当流量到达一定的阈值时，就直接返回“系统繁忙”之类的提示，防止过多的请求打在数据库上，这样虽然难用，但至少可以使用，避免直接把数据库搞挂。

## BigKey

**定义**：BigKey是指存储在Redis中的大尺寸键值对。这些键值对可能包含大量的元素或占用大量的内存空间。

特点：

- **内存占用大**：单个键值对占用的内存空间较大，可能达到数MB甚至更多。
- **操作耗时**：对BigKey进行操作（如读取、写入、删除）可能需要较长时间，影响Redis的响应速度。
- **影响其他操作**：由于Redis是单线程的，处理BigKey的操作可能会阻塞其他操作，导致整体性能下降。

常见场景：

- 存储大量元素的集合（如Set、List、Sorted Set）。
- 存储大量字段的哈希（如Hash）。

处理方法：

- **拆分键值对**：将大的键值对拆分成多个小的键值对。
- **使用更合适的数据结构**：例如，使用Sorted Set代替List存储有序数据。
- **延迟加载**：仅在需要时才加载数据到内存中。

## HotKey

**定义**：HotKey是指在Redis中访问频率非常高的键值对。这些键值对可能由于业务逻辑或用户行为导致被频繁访问。

特点：

- **访问频率高**：单个键值对被频繁访问，可能导致热点数据集中。
- **缓存压力**：频繁的访问可能导致缓存压力增大，尤其是在缓存空间有限的情况下。
- **可能导致缓存击穿**：如果HotKey的缓存过期或被删除，大量请求可能会直接打到数据库，导致缓存击穿。

常见场景：

- 频繁访问的热点数据，如热门商品信息、热门文章等。
- 频繁更新和访问的实时数据，如股票价格、实时排行榜等。

处理方法：

- **缓存预热**：预先将热点数据加载到缓存中。
- **设置合理的过期时间**：避免热点数据频繁过期。
- **使用互斥锁或分布式锁**：在缓存过期时，确保只有一个请求可以访问数据库并回写缓存。



### PS：

​	单飞指解决缓存击穿问题时采用的一种策略，即在缓存失效时，只允许一个请求通过并查询数据库，然后将查询结果回写到缓存中，其他请求则等待缓存重建完成或者直接从缓存中获取数据。

​	下面简单介绍下布隆过滤器：

布隆过滤器底层使用bit数组存储数据，该数组中的元素默认值是0。

布隆过滤器第一次初始化的时候，会把数据库中所有已存在的key，经过一系列的hash算法计算，算出每个key的位置，并将该位置的值置为1，为了减少哈希冲突的影响，可以对每个key进行多次hash计算，如下图

- 通过k个无偏hash函数计算得到k个hash值
- 依次取模数组长度，得到数组索引
- 判断索引处的值是否全部为1，如果全部为1则存在（这种存在可能是误判），如果存在一个0则必定不存在

![img](\assets\68747470733a2f2f696d6167652e6d69616e7368692e6f6e6c696e652f696d673230323230353235323133303134372e6a7067.jpeg)

那使用布隆过滤器就可以完美解决问题了吗？当然没有，使用布隆过滤器解决缓存穿透问题的同时也带来了一些其他问题：

1. 布隆过滤器存在误判的情况
2. 布隆过滤器不支持删除，因为布隆过滤器中存的1可能涉及多个key，直接删除可能会影响到其他key，比如上图第四个位置的1就涉及两个key
3. 如果数据库中数据更新同步到布隆过滤器时失败，布隆过滤器则会将本来正常的请求拦截住，这是非常致命的

先来看第一个问题，前面已经解释过了布隆过滤器存在误判的原因，就是不同的key的hash值可能相同。因为每个key要经过多次hash计算，恰好每次hash计算都和其他key的hash值相同的概率是很低的，有少数的漏网之鱼通过了布隆过滤器也不要紧，所以第一个问题不必担心。如果想要减少hash冲突导致的误判，可以适当**增加key的hash次数**。

第二个问题可以在布隆过滤器中以**计数**的方式存储，如下图

![img](\assets\68747470733a2f2f696d6167652e6d69616e7368692e6f6e6c696e652f696d673230323230353235323133303932362e6a7067.jpeg)

第三个问题出现概率不大，如果这种问题对业务影响很大，可以考虑其他解决缓存穿透的方法。

