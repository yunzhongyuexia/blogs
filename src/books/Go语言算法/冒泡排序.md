---
title: 冒泡排序
cover: http://upyun.yzyx.fun/24.jpg
date: 2024-07-24
category:
  - Go语言算法
tag:
  - 学习资料
---

<!-- more -->

```go
package main

import "fmt"

// 冒泡排序函数
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        // 标记是否发生了交换
        swapped := false
        // 最后一个元素已经排序好，所以每次减少比较的元素数量
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                // 交换 arr[j] 和 arr[j+1]
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = true
            }
        }
        // 如果在这一轮排序中没有发生交换，说明数组已经有序，可以提前结束
        if !swapped {
            break
        }
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println("Original array:", arr)
    bubbleSort(arr)
    fmt.Println("Sorted array:  ", arr)
}
```

冒泡排序和快速排序是两种常见的排序算法，它们的时间复杂度如下：

1. **冒泡排序**：
   - **最好情况**：当输入数组已经是有序的，冒泡排序的时间复杂度为 𝑂(𝑛)*O*(*n*)，其中 𝑛*n* 是数组的长度。
   - **最坏情况**：当输入数组是逆序的，冒泡排序的时间复杂度为 𝑂(𝑛2)*O*(*n*2)。
   - **平均情况**：冒泡排序的平均时间复杂度也是 𝑂(𝑛2)*O*(*n*2)。
2. **快速排序**：
   - **最好情况**：快速排序的时间复杂度为 𝑂(𝑛log⁡𝑛)*O*(*n*log*n*)，这通常发生在每次选择的基准元素都能将数组大致分为两部分时。
   - **最坏情况**：当输入数组已经是有序的（或接近有序），且每次选择的基准元素都是最小或最大值时，快速排序的时间复杂度为 𝑂(𝑛2)*O*(*n*2)。
   - **平均情况**：快速排序的平均时间复杂度为 𝑂(𝑛log⁡𝑛)*O*(*n*log*n*)。

快速排序在实际应用中通常比冒泡排序更高效，尤其是在处理大数据集时。然而，快速排序的性能依赖于基准元素的选择，因此在最坏情况下可能会退化到 𝑂(𝑛2)*O*(*n*2)。为了避免这种情况，通常会采用随机选择基准元素的方法来提高其平均性能。



冒泡排序和快速排序在稳定性方面有所不同：

1. **冒泡排序**：
   - 冒泡排序是一种**稳定**的排序算法。稳定性指的是在排序过程中，相等的元素之间的相对顺序不会改变。冒泡排序通过相邻元素的比较和交换来工作，如果两个元素相等，它们就不会交换位置，因此保持了它们的原始顺序。
2. **快速排序**：
   - 快速排序通常被认为是**不稳定**的排序算法。这是因为在分区过程中，如果遇到相等的元素，它们可能会被交换位置，从而改变了它们原来的相对顺序。然而，这并不是绝对的，快速排序的稳定性取决于具体的实现。有些变种的快速排序算法，如三数取中法（median-of-three pivot selection）和随机选择基准元素的方法，可以减少稳定性问题，但通常不会完全消除。

稳定性是排序算法的一个重要属性，特别是在需要保持相等元素原始顺序的应用场景中。如果稳定性是一个关键需求，选择冒泡排序或其它稳定的排序算法（如插入排序、归并排序等）可能更合适。
