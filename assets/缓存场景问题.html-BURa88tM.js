import{_ as e,c as i,a as l,d as t,o as s}from"./app-CKza1MQ-.js";const n="/assets/68747470733a2f2f696d6167652e6d69616e7368692e6f6e6c696e652f696d673230323230353235323133303134372e6a7067-Bq8JBNIs.jpeg",o="/assets/68747470733a2f2f696d6167652e6d69616e7368692e6f6e6c696e652f696d673230323230353235323133303932362e6a7067-BbHVRIcA.jpeg",r={},a=t('<h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><ul><li><strong>定义</strong>：缓存穿透是指查询一个不存在的数据，由于缓存和数据库中都没有，导致每次请求都直接查询数据库，这可能对数据库造成很大压力。</li><li><strong>原因</strong>：通常是因为攻击者故意发起大量不存在的数据查询请求，或者由于数据未被预先加载到缓存中。</li><li><strong>解决方法</strong>：使用空队列，也可以通过布隆过滤器（布谷鸟过滤器）拦截这些不存在的数据查询，或者使用缓存预热策略预先加载可能被查询的数据到缓存中。</li></ul><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h2><ul><li><strong>定义</strong>：缓存击穿是指一个存在的key，在缓存中过期了，同时有大量的请求请求这个key，这些请求都会直接打到数据库上，导致数据库压力过大。</li><li><strong>原因</strong>：通常是因为某个热点数据在缓存中过期，而此时有大量的并发请求需要访问这个数据。</li><li><strong>解决方法</strong>：最好用的是单飞；也可以使用互斥锁或分布式锁来保证在缓存过期的情况下，只有一个请求能够访问数据库并回写缓存，其他请求则等待缓存重建完成。此外，可以设置缓存的过期时间更加分散，避免大量缓存同时过期。</li></ul><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><ul><li><strong>定义</strong>：缓存雪崩是指在某一个时刻出现大规模的缓存失效的情况，大量的请求直接打在数据库上面，可能会导致数据库宕机，如果这时重启数据库并不能解决根本问题，会再次造成缓存雪崩。</li><li><strong>原因</strong>：通常是因为缓存的过期时间设置不当，导致大量缓存在同一时间过期，或Redis宕机了。</li><li><strong>解决方法</strong>： <ul><li>为避免Redis宕机造成缓存雪崩，可以搭建Redis集群；</li><li>尽量不要设置相同的过期时间，例如可以在原有的过期时间加上随机数；</li><li>服务降级，当流量到达一定的阈值时，就直接返回“系统繁忙”之类的提示，防止过多的请求打在数据库上，这样虽然难用，但至少可以使用，避免直接把数据库搞挂。</li></ul></li></ul><h2 id="bigkey" tabindex="-1"><a class="header-anchor" href="#bigkey"><span>BigKey</span></a></h2><p><strong>定义</strong>：BigKey是指存储在Redis中的大尺寸键值对。这些键值对可能包含大量的元素或占用大量的内存空间。</p><p>特点：</p><ul><li><strong>内存占用大</strong>：单个键值对占用的内存空间较大，可能达到数MB甚至更多。</li><li><strong>操作耗时</strong>：对BigKey进行操作（如读取、写入、删除）可能需要较长时间，影响Redis的响应速度。</li><li><strong>影响其他操作</strong>：由于Redis是单线程的，处理BigKey的操作可能会阻塞其他操作，导致整体性能下降。</li></ul><p>常见场景：</p><ul><li>存储大量元素的集合（如Set、List、Sorted Set）。</li><li>存储大量字段的哈希（如Hash）。</li></ul><p>处理方法：</p><ul><li><strong>拆分键值对</strong>：将大的键值对拆分成多个小的键值对。</li><li><strong>使用更合适的数据结构</strong>：例如，使用Sorted Set代替List存储有序数据。</li><li><strong>延迟加载</strong>：仅在需要时才加载数据到内存中。</li></ul><h2 id="hotkey" tabindex="-1"><a class="header-anchor" href="#hotkey"><span>HotKey</span></a></h2><p><strong>定义</strong>：HotKey是指在Redis中访问频率非常高的键值对。这些键值对可能由于业务逻辑或用户行为导致被频繁访问。</p><p>特点：</p><ul><li><strong>访问频率高</strong>：单个键值对被频繁访问，可能导致热点数据集中。</li><li><strong>缓存压力</strong>：频繁的访问可能导致缓存压力增大，尤其是在缓存空间有限的情况下。</li><li><strong>可能导致缓存击穿</strong>：如果HotKey的缓存过期或被删除，大量请求可能会直接打到数据库，导致缓存击穿。</li></ul><p>常见场景：</p><ul><li>频繁访问的热点数据，如热门商品信息、热门文章等。</li><li>频繁更新和访问的实时数据，如股票价格、实时排行榜等。</li></ul><p>处理方法：</p><ul><li><strong>缓存预热</strong>：预先将热点数据加载到缓存中。</li><li><strong>设置合理的过期时间</strong>：避免热点数据频繁过期。</li><li><strong>使用互斥锁或分布式锁</strong>：在缓存过期时，确保只有一个请求可以访问数据库并回写缓存。</li></ul><h3 id="ps" tabindex="-1"><a class="header-anchor" href="#ps"><span>PS：</span></a></h3><p>​ 单飞指解决缓存击穿问题时采用的一种策略，即在缓存失效时，只允许一个请求通过并查询数据库，然后将查询结果回写到缓存中，其他请求则等待缓存重建完成或者直接从缓存中获取数据。</p><p>​ 下面简单介绍下布隆过滤器：</p><p>布隆过滤器底层使用bit数组存储数据，该数组中的元素默认值是0。</p><p>布隆过滤器第一次初始化的时候，会把数据库中所有已存在的key，经过一系列的hash算法计算，算出每个key的位置，并将该位置的值置为1，为了减少哈希冲突的影响，可以对每个key进行多次hash计算，如下图</p><ul><li>通过k个无偏hash函数计算得到k个hash值</li><li>依次取模数组长度，得到数组索引</li><li>判断索引处的值是否全部为1，如果全部为1则存在（这种存在可能是误判），如果存在一个0则必定不存在</li></ul><figure><img src="'+n+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>那使用布隆过滤器就可以完美解决问题了吗？当然没有，使用布隆过滤器解决缓存穿透问题的同时也带来了一些其他问题：</p><ol><li>布隆过滤器存在误判的情况</li><li>布隆过滤器不支持删除，因为布隆过滤器中存的1可能涉及多个key，直接删除可能会影响到其他key，比如上图第四个位置的1就涉及两个key</li><li>如果数据库中数据更新同步到布隆过滤器时失败，布隆过滤器则会将本来正常的请求拦截住，这是非常致命的</li></ol><p>先来看第一个问题，前面已经解释过了布隆过滤器存在误判的原因，就是不同的key的hash值可能相同。因为每个key要经过多次hash计算，恰好每次hash计算都和其他key的hash值相同的概率是很低的，有少数的漏网之鱼通过了布隆过滤器也不要紧，所以第一个问题不必担心。如果想要减少hash冲突导致的误判，可以适当<strong>增加key的hash次数</strong>。</p><p>第二个问题可以在布隆过滤器中以<strong>计数</strong>的方式存储，如下图</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>第三个问题出现概率不大，如果这种问题对业务影响很大，可以考虑其他解决缓存穿透的方法。</p>',35);function g(h,p){return s(),i("div",null,[l(" more "),a])}const c=e(r,[["render",g],["__file","缓存场景问题.html.vue"]]),u=JSON.parse('{"path":"/books/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%BC%93%E5%AD%98%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98.html","title":"缓存场景问题","lang":"zh-CN","frontmatter":{"title":"缓存场景问题","cover":"https://upyun.yzyx.fun/8.jpg","date":"2024-07-26T00:00:00.000Z","category":["Redis"],"tag":["学习资料"]},"headers":[{"level":2,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[]},{"level":2,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[]},{"level":2,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[]},{"level":2,"title":"BigKey","slug":"bigkey","link":"#bigkey","children":[]},{"level":2,"title":"HotKey","slug":"hotkey","link":"#hotkey","children":[{"level":3,"title":"PS：","slug":"ps","link":"#ps","children":[]}]}],"git":{"createdTime":1723164889000,"updatedTime":1723164889000,"contributors":[{"name":"yunzhongyue","email":"15737369015@163.com","commits":1}]},"readingTime":{"minutes":5.93,"words":1778},"filePathRelative":"books/数据库/Redis/缓存场景问题.md","localizedDate":"2024年7月26日","excerpt":""}');export{c as comp,u as data};
